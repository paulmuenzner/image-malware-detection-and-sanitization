import os
import os.path
import sys
import traceback
from typing import Dict, List, Union

sys.path.append(
    os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))
)
from typing import List, TypedDict

from interfaces.occurrence_validation import OccurrenceList
from interfaces.signature_list import SignatureListInterface
from utils.check_chunk_order import check_chunk_order_step_4_5
from utils.chunk_occurrence import validate_occurrence
from utils.collection_methods import count_collection_values, is_collection_empty
from utils.select_signature_lib import select_signature_lib
from utils.start_end_validate import string_ends_with, string_starts_with


class ResultOccurrence(TypedDict):
    number: str
    positions: List[int]
    name: str


###########################################################################################
# Validate order of image chunks to each other
def position_validation(
    file_string: str, extension: str
) -> dict[str, str | List[int]] | list:
    try:
        signature_lib: SignatureListInterface = select_signature_lib(extension)

        # Collecting all occurring chunks appearing in png
        chunk_positions: OccurrenceList = []

        # Loop through each possible chunk in lib
        for key, value in signature_lib.items():

            # Occurrence validation for each chunk
            occurrence_validation = validate_occurrence(file_string, key, value)

            # Add all in file appearing chunks with its index position to chunk_positions
            positions = occurrence_validation["index_positions"]
            if is_collection_empty(positions) == False:
                chunk_positions.append({"name": key, "indexes": positions})

        wrong_positions: dict[str, str | List[int]] | list = []
        for key in chunk_positions:
            # Currently to check chunk
            chunk_name_to_check: str = key["name"]
            indexes_of_chunk_to_check = key["indexes"]
            lib_item = signature_lib[chunk_name_to_check]
            # Lib restrictions of currently to check chunk
            must_be_before_chunk = lib_item["ordering"]["before"]
            must_be_after_chunk = lib_item["ordering"]["after"]
            signature_chunk = lib_item["signature"]

            ###########################################################
            # Status Evaluations need for following steps
            only_one_before_restriction = (
                count_collection_values(must_be_before_chunk) == 1
            )  # eg. "before": ["all"]
            no_after_restriction = (
                count_collection_values(must_be_after_chunk) == 0
            )  # eg. "after": []
            no_before_restriction = (
                count_collection_values(must_be_before_chunk) == 0
            )  # eg. "before": []
            only_one_restriction_at_end = (
                count_collection_values(must_be_after_chunk) == 1
            )  # eg. "after": ["all"]
            more_than_zero_after_restrictions = (
                count_collection_values(must_be_after_chunk) > 0
            )
            more_than_zero_before_restrictions = (
                count_collection_values(must_be_before_chunk) > 0
            )

            ########################################################################
            ####################### START VALIDATION ###############################
            ########################################################################

            ####################### 1. lib restriction #############################
            # Skip file chunks without position restrictions. No validation needed
            # "ordering": {"before": [], "after": []}
            if is_collection_empty(must_be_before_chunk) and is_collection_empty(
                must_be_after_chunk
            ):
                continue

            ####################### 2. lib restriction ####################################
            # Validate file chunks where it must be positioned at the very beginning of file
            # "ordering": {"before": ["all"], "after": []}
            if (
                only_one_before_restriction
                and must_be_before_chunk[0] == "all"
                and no_after_restriction
            ):
                # Validate if chunk in file corresponds with lib restriction
                if not count_collection_values(indexes_of_chunk_to_check) == 1:
                    wrong_positions.append(
                        {
                            "name": chunk_name_to_check,
                            "indexes": indexes_of_chunk_to_check,
                            "error": f"2nd Verfification Step: Chunk '{chunk_name_to_check}' must only appear once. But it appears at indexes: {indexes_of_chunk_to_check}",
                        }
                    )

                if not string_starts_with(file_string, signature_chunk):
                    wrong_positions.append(
                        {
                            "name": chunk_name_to_check,
                            "indexes": indexes_of_chunk_to_check,
                            "error": f"2nd Verfification Step: Chunk '{chunk_name_to_check}' must appear at the very beginning but doesn't. It appears at index: {indexes_of_chunk_to_check}",
                        }
                    )

            ####################### 3. lib restriction ####################################
            # Validate file chunks where it must be positioned at the very end of file
            # "ordering": {"before": [], "after": ["all"]}
            if (
                no_before_restriction
                and must_be_after_chunk[0] == "all"
                and only_one_restriction_at_end
            ):
                # Validate if chunk in file corresponds with lib restriction
                if not string_ends_with(file_string, signature_chunk):
                    wrong_positions.append(
                        {
                            "name": chunk_name_to_check,
                            "indexes": indexes_of_chunk_to_check,
                            "error": f"3rd Verfification Step: Chunk '{chunk_name_to_check}' must only appear at the end. But it appears at indexes: {indexes_of_chunk_to_check}",
                        }
                    )

            ####################### 4. lib restriction #####################################################################
            # Validate file chunks where it must be positioned at the beginning despite of chunks mentioned under key "after"
            # eg. {"before": ["all"], "after": ["start"]} or {"before": ["all"], "after": ["start", "tEXt", "hIST"]}
            if (
                only_one_before_restriction
                and must_be_before_chunk[0] == "all"
                and more_than_zero_after_restrictions
            ):
                wrong_position_check = check_chunk_order_step_4_5(
                    chunk_name_to_check,
                    indexes_of_chunk_to_check,
                    must_be_after_chunk,
                    chunk_positions,
                )
                your_list_length = len(wrong_position_check)
                if your_list_length > 0:
                    wrong_positions.append(wrong_position_check[0])

            ####################### 5. lib restriction #######################################################################################
            # Validate file chunks where it must be positioned after any chunk mentioned under key "after" but without before restriction
            # eg. "after": ["cHRM"] or "after": ["tEXt", "hIST", "cHRM"]
            if more_than_zero_after_restrictions and must_be_after_chunk[0] != "all":
                # Loop all chunk names which must be before current chunk
                # must_be_after_chunk (eg. "after": ["tEXt", "hIST", "cHRM"]) lists all chunks names where current chunk must be positioned after in image file
                # Each key is one chunk name which must be positioned before
                wrong_position_check = check_chunk_order_step_4_5(
                    chunk_name_to_check,
                    indexes_of_chunk_to_check,
                    must_be_after_chunk,
                    chunk_positions,
                )
                your_list_length = len(wrong_position_check)
                if your_list_length > 0:
                    wrong_positions.append(wrong_position_check[0])

            ####################### 6. lib restriction #######################################################################################
            # Validate file chunk where it must be positioned before any chunk mentioned under key "before" but without before restriction
            # Opposite of 5th validation
            # eg. "before": ["cHRM"] or "before": ["tEXt", "hIST", "cHRM"]
            if more_than_zero_before_restrictions and must_be_before_chunk[0] != "all":
                # Loop all chunk names which must be after current chunk
                # must_be_before_chunk (eg. "before": ["tEXt", "hIST", "cHRM"]) lists all chunks names where current chunk must be positioned before in file
                # Each key is one chunk name which must be positioned after
                for key in must_be_before_chunk:

                    # Check if this chunk which must be positioned after exists in current to check file. All in file existing chunks are listed in 'chunk_positions'
                    # With key, we already have name but not position values
                    # Filter name and indexes (position in file) of chunk which must be after chunk
                    filter_from_chunk_positions = [
                        chunk_positions
                        for chunk_positions in chunk_positions
                        if chunk_positions["name"] == key
                    ]

                    # Name (from "after" list) of chunk where current chunk of this loop step must be positioned before
                    name: str = filter_from_chunk_positions[0]["name"]
                    indexes_of_after_chunk: List[int] = filter_from_chunk_positions[0][
                        "indexes"
                    ]

                    # Loop and check each index where chunk which must be positioned before
                    for one_index_of_after in indexes_of_after_chunk:
                        # Current chunk might appear multiple times too. Because of that we have to check each and loop again
                        for one_index_of_current_chunk in indexes_of_chunk_to_check:
                            # Now, we are able to compare positions
                            if one_index_of_after < one_index_of_current_chunk:
                                wrong_positions.append(
                                    {
                                        "name": chunk_name_to_check,
                                        "indexes": indexes_of_chunk_to_check,
                                        "error": f"6th Verfification Step: Chunk '{chunk_name_to_check}' must appear before chunk {name}. But '{chunk_name_to_check}' appears at position {one_index_of_current_chunk} which is after chunk '{name}' with position of {one_index_of_after}.",
                                    }
                                )
        return wrong_positions
    except ValueError as e:
        raise ValueError(f"ValueError in 'validate_occurrence': {e}")
    except Exception as e:
        traceback.print_exc()
        raise Exception(f"ExceptionError in 'validate_occurrence': {e}")
